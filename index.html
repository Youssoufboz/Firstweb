<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Neon Runner - 2D Adventure</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    background: #0a0a0a;
    color: #fff;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
}
#gameCanvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}
.hud {
    position: absolute;
    top: 15px;
    left: 15px;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px #000;
    z-index: 10;
}
.level-display {
    position: absolute;
    top: 15px;
    right: 15px;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 2px 2px 4px #000;
    color: #00ff88;
    z-index: 10;
}
.lives {
    color: #ff3366;
}
.coins {
    color: #ffd700;
}
.controls {
    position: absolute;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
    z-index: 10;
}
.dpad {
    display: flex;
    gap: 10px;
}
.btn {
    background: rgba(255, 255, 255, 0.15);
    border: 3px solid rgba(255, 255, 255, 0.4);
    border-radius: 50%;
    width: 65px;
    height: 65px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    color: white;
    user-select: none;
    cursor: pointer;
    backdrop-filter: blur(10px);
}
.btn:active {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(0.95);
}
.btn-jump {
    background: rgba(255, 51, 102, 0.2);
    border-color: #ff3366;
}
.btn-jump:active {
    background: rgba(255, 51, 102, 0.4);
}
.message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 40px;
    border-radius: 15px;
    border: 3px solid #ff3366;
    text-align: center;
    display: none;
    z-index: 100;
}
.message h2 {
    font-size: 36px;
    margin-bottom: 15px;
    color: #ff3366;
}
.message button {
    margin-top: 20px;
    padding: 12px 30px;
    font-size: 18px;
    background: #ff3366;
    border: none;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    font-weight: bold;
}
.message button:hover {
    background: #ff5588;
}
@media (max-width: 600px) {
    .btn { width: 55px; height: 55px; font-size: 24px; }
    .hud { font-size: 16px; }
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div class="hud">
    <div class="lives">‚ù§Ô∏è Lives: <span id="lives">3</span></div>
    <div class="coins">ü™ô Coins: <span id="coins">0</span></div>
    <div>‚≠ê Score: <span id="score">0</span></div>
</div>

<div class="level-display">
    Level <span id="levelNum">1</span>
</div>

<div class="controls">
    <div class="dpad">
        <div class="btn" id="leftBtn">‚óÄ</div>
        <div class="btn" id="rightBtn">‚ñ∂</div>
    </div>
    <div class="btn btn-jump" id="jumpBtn">‚Üë</div>
</div>

<div class="message" id="gameOver">
    <h2>Game Over!</h2>
    <div style="font-size: 24px; margin: 10px 0;">Final Score: <span id="finalScore">0</span></div>
    <div style="font-size: 18px; margin: 10px 0;">Continue from Level <span id="continueLevel">1</span></div>
    <button onclick="restart()">Continue</button>
</div>

<div class="message" id="levelComplete">
    <h2>Level Complete! üéâ</h2>
    <div style="font-size: 24px; margin: 10px 0;">Score: <span id="levelScore">0</span></div>
    <button onclick="nextLevel()">Next Level</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
}
resize();
window.addEventListener('resize', resize);

const game = {
    keys: {},
    player: null,
    camera: { x: 0, y: 0 },
    level: 1,
    maxLevelReached: 1,
    lives: 3,
    coins: 0,
    score: 0,
    entities: [],
    particles: [],
    levelWidth: 0,
    gameOver: false,
    levelComplete: false
};

// Controls
['leftBtn', 'rightBtn', 'jumpBtn'].forEach(id => {
    const btn = document.getElementById(id);
    const key = id.replace('Btn', '');
    
    btn.addEventListener('mousedown', e => { 
        game.keys[key] = true;
        if (key === 'jump') game.keys.jumpPressed = true;
        e.preventDefault();
    });
    btn.addEventListener('mouseup', e => { 
        game.keys[key] = false;
        if (key === 'jump') game.keys.jumpPressed = false;
        e.preventDefault();
    });
    btn.addEventListener('touchstart', e => { 
        game.keys[key] = true;
        if (key === 'jump') game.keys.jumpPressed = true;
        e.preventDefault();
    });
    btn.addEventListener('touchend', e => { 
        game.keys[key] = false;
        if (key === 'jump') game.keys.jumpPressed = false;
        e.preventDefault();
    });
});

window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        if (!game.keys.jump) {
            game.keys.jump = true;
            game.keys.jumpPressed = true;
        }
    }
});
window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        game.keys.jump = false;
        game.keys.jumpPressed = false;
    }
});

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 32;
        this.h = 48;
        this.vx = 0;
        this.vy = 0;
        this.speed = 5;
        this.jumpPower = -13;
        this.grounded = false;
        this.canJump = true;
        this.facingRight = true;
        this.jumpBufferTime = 0;
        this.coyoteTime = 0;
        this.doubleJumpAvailable = true;
    }
    
    update() {
        const wasGrounded = this.grounded;
        
        if (game.keys.left) {
            this.vx = -this.speed;
            this.facingRight = false;
        } else if (game.keys.right) {
            this.vx = this.speed;
            this.facingRight = true;
        } else {
            this.vx *= 0.8;
        }
        
        // Gravity
        this.vy += 0.5;
        if (this.vy > 15) this.vy = 15;
        
        // Variable jump height
        if (!game.keys.jump && this.vy < 0) {
            this.vy *= 0.85;
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        this.grounded = false;
        
        // Collision with platforms
        game.entities.forEach(ent => {
            if (ent.type === 'platform') {
                if (this.x < ent.x + ent.w && this.x + this.w > ent.x &&
                    this.y < ent.y + ent.h && this.y + this.h > ent.y) {
                    
                    const overlapX = Math.min(this.x + this.w - ent.x, ent.x + ent.w - this.x);
                    const overlapY = Math.min(this.y + this.h - ent.y, ent.y + ent.h - this.y);
                    
                    if (overlapX < overlapY) {
                        this.x += (this.x < ent.x) ? -overlapX : overlapX;
                        this.vx = 0;
                    } else {
                        if (this.vy > 0) {
                            this.y = ent.y - this.h;
                            this.vy = 0;
                            this.grounded = true;
                            this.canJump = true;
                            this.coyoteTime = 8;
                            this.doubleJumpAvailable = true; // Reset double jump when landing
                        } else {
                            this.y = ent.y + ent.h;
                            this.vy = 0;
                        }
                    }
                }
            }
        });
        
        // Coyote time (grace period after leaving platform)
        if (!this.grounded && wasGrounded) {
            this.coyoteTime = 8;
        }
        if (this.coyoteTime > 0) this.coyoteTime--;
        
        // Jump buffer
        if (game.keys.jumpPressed) {
            this.jumpBufferTime = 8;
            game.keys.jumpPressed = false;
        }
        if (this.jumpBufferTime > 0) this.jumpBufferTime--;
        
        // Jump with buffer and coyote time
        if (this.jumpBufferTime > 0 && (this.grounded || this.coyoteTime > 0) && this.canJump) {
            this.vy = this.jumpPower;
            this.grounded = false;
            this.canJump = false;
            this.coyoteTime = 0;
            this.jumpBufferTime = 0;
            this.doubleJumpAvailable = true; // Reset double jump when jumping from ground
        }
        // Double jump in air
        else if (this.jumpBufferTime > 0 && !this.grounded && this.coyoteTime <= 0 && this.doubleJumpAvailable) {
            this.vy = this.jumpPower;
            this.doubleJumpAvailable = false;
            this.jumpBufferTime = 0;
            // Particle effect for double jump
            for (let i = 0; i < 8; i++) {
                game.particles.push(new Particle(this.x + this.w/2, this.y + this.h, '#00ccff'));
            }
        }
        
        // Check coins
        game.entities.forEach((ent, i) => {
            if (ent.type === 'coin' && !ent.collected) {
                const dist = Math.hypot(this.x + this.w/2 - (ent.x + ent.w/2), 
                                       this.y + this.h/2 - (ent.y + ent.h/2));
                if (dist < 30) {
                    ent.collected = true;
                    game.coins++;
                    game.score += 50;
                    updateHUD();
                    for (let j = 0; j < 10; j++) {
                        game.particles.push(new Particle(ent.x + ent.w/2, ent.y + ent.h/2, '#ffd700'));
                    }
                }
            }
        });
        
        // Check enemies
        game.entities.forEach(ent => {
            if (ent.type === 'enemy' && !ent.dead) {
                if (this.x < ent.x + ent.w && this.x + this.w > ent.x &&
                    this.y < ent.y + ent.h && this.y + this.h > ent.y) {
                    
                    if (this.vy > 0 && this.y + this.h/2 < ent.y + ent.h/2) {
                        ent.dead = true;
                        this.vy = -10;
                        game.score += 100;
                        updateHUD();
                        for (let j = 0; j < 15; j++) {
                            game.particles.push(new Particle(ent.x + ent.w/2, ent.y + ent.h/2, '#ff3366'));
                        }
                    } else {
                        this.hit();
                    }
                }
            }
        });
        
        // Check goal
        game.entities.forEach(ent => {
            if (ent.type === 'goal') {
                if (this.x < ent.x + ent.w && this.x + this.w > ent.x &&
                    this.y < ent.y + ent.h && this.y + this.h > ent.y) {
                    levelComplete();
                }
            }
        });
        
        // Fall death
        if (this.y > H + 100) {
            this.hit();
        }
    }
    
    hit() {
        game.lives--;
        updateHUD();
        if (game.lives <= 0) {
            endGame();
        } else {
            this.x = 50;
            this.y = 300;
            this.vx = 0;
            this.vy = 0;
        }
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        
        // Draw Luffy-style character
        // Skin tone
        ctx.fillStyle = '#fdc689';
        
        // Head
        ctx.fillRect(cx + 8, cy + 4, 16, 16);
        
        // Body (red vest)
        ctx.fillStyle = '#dc143c';
        ctx.fillRect(cx + 10, cy + 20, 12, 12);
        
        // Arms
        ctx.fillStyle = '#fdc689';
        ctx.fillRect(cx + 6, cy + 22, 4, 10);
        ctx.fillRect(cx + 22, cy + 22, 4, 10);
        
        // Shorts (blue)
        ctx.fillStyle = '#4169e1';
        ctx.fillRect(cx + 10, cy + 32, 12, 8);
        
        // Legs
        ctx.fillStyle = '#fdc689';
        ctx.fillRect(cx + 10, cy + 40, 4, 8);
        ctx.fillRect(cx + 18, cy + 40, 4, 8);
        
        // Eyes
        ctx.fillStyle = '#000';
        if (this.facingRight) {
            ctx.fillRect(cx + 16, cy + 8, 4, 4);
        } else {
            ctx.fillRect(cx + 12, cy + 8, 4, 4);
        }
        
        // Smile
        ctx.fillStyle = '#000';
        ctx.fillRect(cx + 12, cy + 14, 8, 2);
        
        // Straw hat
        ctx.fillStyle = '#f4c542';
        ctx.fillRect(cx + 6, cy + 2, 20, 4);
        ctx.fillRect(cx + 10, cy, 12, 2);
        
        // Hat ribbon
        ctx.fillStyle = '#dc143c';
        ctx.fillRect(cx + 8, cy + 4, 16, 2);
    }
}

class Platform {
    constructor(x, y, w, h, color = '#444') {
        this.type = 'platform';
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = color;
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        ctx.fillStyle = this.color;
        ctx.fillRect(cx, cy, this.w, this.h);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, this.w, this.h);
    }
}

class Coin {
    constructor(x, y) {
        this.type = 'coin';
        this.x = x;
        this.y = y;
        this.w = 24;
        this.h = 24;
        this.collected = false;
        this.angle = 0;
    }
    
    update() {
        this.angle += 0.1;
    }
    
    draw() {
        if (!this.collected) {
            const cx = this.x - game.camera.x;
            const cy = this.y - game.camera.y;
            ctx.save();
            ctx.translate(cx + this.w/2, cy + this.h/2);
            ctx.rotate(this.angle);
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffed4e';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
}

class Enemy {
    constructor(x, y, range) {
        this.type = 'enemy';
        this.x = x;
        this.y = y;
        this.w = 36;
        this.h = 36;
        this.startX = x;
        this.range = range;
        this.speed = 2;
        this.dir = 1;
        this.dead = false;
    }
    
    update() {
        if (!this.dead) {
            this.x += this.speed * this.dir;
            if (this.x > this.startX + this.range || this.x < this.startX) {
                this.dir *= -1;
            }
        }
    }
    
    draw() {
        if (!this.dead) {
            const cx = this.x - game.camera.x;
            const cy = this.y - game.camera.y;
            
            // Draw Marine-style enemy
            // Navy cap/head
            ctx.fillStyle = '#0047ab';
            ctx.fillRect(cx + 6, cy + 2, 24, 8);
            
            // Face
            ctx.fillStyle = '#fdc689';
            ctx.fillRect(cx + 8, cy + 8, 20, 12);
            
            // Eyes (angry)
            ctx.fillStyle = '#000';
            ctx.fillRect(cx + 12, cy + 12, 3, 3);
            ctx.fillRect(cx + 21, cy + 12, 3, 3);
            
            // Marine coat (white with blue)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(cx + 10, cy + 20, 16, 10);
            
            // Blue trim
            ctx.fillStyle = '#0047ab';
            ctx.fillRect(cx + 10, cy + 20, 16, 2);
            
            // Pants
            ctx.fillStyle = '#000080';
            ctx.fillRect(cx + 12, cy + 30, 12, 6);
            
            // Marine symbol
            ctx.fillStyle = '#0047ab';
            ctx.fillRect(cx + 16, cy + 22, 4, 6);
        }
    }
}

class Goal {
    constructor(x, y) {
        this.type = 'goal';
        this.x = x;
        this.y = y;
        this.w = 48;
        this.h = 64;
        this.pulse = 0;
    }
    
    update() {
        this.pulse += 0.1;
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        const glow = Math.sin(this.pulse) * 10 + 20;
        
        ctx.fillStyle = '#00ff88';
        ctx.shadowBlur = glow;
        ctx.shadowColor = '#00ff88';
        ctx.fillRect(cx, cy, this.w, this.h);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#fff';
        ctx.font = '30px Arial';
        ctx.fillText('üèÅ', cx + 8, cy + 40);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10 - 3;
        this.life = 1;
        this.color = color;
        this.size = Math.random() * 4 + 2;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.3;
        this.life -= 0.02;
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(cx, cy, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

function createLevel(level) {
    game.entities = [];
    
    if (level === 1) {
        game.levelWidth = 3000;
        for (let i = 0; i < 3000; i += 200) {
            game.entities.push(new Platform(i, H - 60, 200, 60, '#2d4a3e'));
        }
        
        game.entities.push(new Platform(300, H - 200, 200, 30));
        game.entities.push(new Platform(600, H - 300, 150, 30));
        game.entities.push(new Platform(900, H - 400, 200, 30));
        game.entities.push(new Platform(1200, H - 250, 180, 30));
        game.entities.push(new Platform(1500, H - 350, 150, 30));
        game.entities.push(new Platform(1800, H - 450, 200, 30));
        game.entities.push(new Platform(2100, H - 300, 180, 30));
        game.entities.push(new Platform(2400, H - 400, 150, 30));
        
        for (let i = 350; i < 3000; i += 300) {
            game.entities.push(new Coin(i, H - 350));
        }
        
        game.entities.push(new Enemy(700, H - 340, 100));
        game.entities.push(new Enemy(1300, H - 290, 120));
        game.entities.push(new Enemy(1900, H - 490, 150));
        game.entities.push(new Enemy(2200, H - 340, 100));
        
        game.entities.push(new Goal(2700, H - 460));
    } else if (level === 2) {
        game.levelWidth = 4000;
        game.entities.push(new Platform(0, H - 60, 500, 60, '#2d4a3e'));
        game.entities.push(new Platform(700, H - 60, 600, 60, '#2d4a3e'));
        game.entities.push(new Platform(1500, H - 60, 500, 60, '#2d4a3e'));
        game.entities.push(new Platform(2200, H - 60, 800, 60, '#2d4a3e'));
        game.entities.push(new Platform(3200, H - 60, 800, 60, '#2d4a3e'));
        
        for (let i = 0; i < 8; i++) {
            game.entities.push(new Platform(400 + i * 400, H - 200 - i * 50, 150, 30));
        }
        
        for (let i = 300; i < 4000; i += 250) {
            game.entities.push(new Coin(i, H - 300 - Math.random() * 200));
        }
        
        for (let i = 0; i < 8; i++) {
            game.entities.push(new Enemy(600 + i * 500, H - 250 - i * 50, 150));
        }
        
        game.entities.push(new Goal(3700, H - 460));
    } else if (level === 3) {
        game.levelWidth = 5000;
        for (let i = 0; i < 5000; i += 300) {
            game.entities.push(new Platform(i, H - 60, 200, 60, '#2d4a3e'));
        }
        
        for (let i = 0; i < 10; i++) {
            game.entities.push(new Platform(300 + i * 450, H - 250 - Math.random() * 200, 120, 30));
        }
        
        for (let i = 400; i < 5000; i += 200) {
            game.entities.push(new Coin(i, H - 400 - Math.random() * 150));
        }
        
        for (let i = 0; i < 12; i++) {
            game.entities.push(new Enemy(500 + i * 400, H - 300, 180));
        }
        
        game.entities.push(new Goal(4700, H - 460));
    }
}

function updateCamera() {
    const targetX = game.player.x - W / 3;
    game.camera.x += (targetX - game.camera.x) * 0.1;
    
    if (game.camera.x < 0) game.camera.x = 0;
    if (game.camera.x > game.levelWidth - W) game.camera.x = game.levelWidth - W;
    
    game.camera.y = 0;
}

function updateHUD() {
    document.getElementById('lives').textContent = game.lives;
    document.getElementById('coins').textContent = game.coins;
    document.getElementById('score').textContent = game.score;
    document.getElementById('levelNum').textContent = game.level;
}

function levelComplete() {
    if (!game.levelComplete) {
        game.levelComplete = true;
        game.score += game.coins * 10 + game.lives * 200;
        
        if (game.level > game.maxLevelReached) {
            game.maxLevelReached = game.level;
        }
        
        document.getElementById('levelScore').textContent = game.score;
        document.getElementById('levelComplete').style.display = 'block';
    }
}

function nextLevel() {
    document.getElementById('levelComplete').style.display = 'none';
    game.level++;
    game.levelComplete = false;
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function endGame() {
    if (!game.gameOver) {
        game.gameOver = true;
        document.getElementById('finalScore').textContent = game.score;
        document.getElementById('continueLevel').textContent = game.maxLevelReached;
        document.getElementById('gameOver').style.display = 'block';
    }
}

function restart() {
    document.getElementById('gameOver').style.display = 'none';
    game.gameOver = false;
    game.levelComplete = false;
    game.level = game.maxLevelReached;
    game.lives = 3;
    game.coins = 0;
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function init() {
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function draw() {
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(1, '#16213e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 50; i++) {
        const x = (i * 137.5) % W;
        const y = (i * 73.2) % H;
        ctx.fillRect(x, y, 2, 2);
    }
    
    game.entities.forEach(ent => {
        if (ent.update) ent.update();
        ent.draw();
    });
    
    game.player.draw();
    
    game.particles = game.particles.filter(p => p.life > 0);
    game.particles.forEach(p => {
        p.update();
        p.draw();
    });
}

function loop() {
    if (!game.gameOver && !game.levelComplete) {
        game.player.update();
        updateCamera();
    }
    draw();
    requestAnimationFrame(loop);
}

init();
loop();
</script>
</body>
</html>