<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Pirate Adventure - Epic Platformer</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    background: #0a0a0a;
    color: #fff;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
}
#gameCanvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}
.hud {
    position: absolute;
    top: 15px;
    left: 15px;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 2px 2px 4px #000;
    z-index: 10;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 10px;
}
.level-display {
    position: absolute;
    top: 15px;
    right: 15px;
    font-size: 22px;
    font-weight: bold;
    text-shadow: 2px 2px 4px #000;
    color: #00ff88;
    z-index: 10;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 10px;
}
.combo {
    position: absolute;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 32px;
    font-weight: bold;
    color: #ffd700;
    text-shadow: 3px 3px 6px #000;
    display: none;
    animation: bounce 0.5s;
    z-index: 10;
}
@keyframes bounce {
    0%, 100% { transform: translateX(-50%) scale(1); }
    50% { transform: translateX(-50%) scale(1.3); }
}
.power-bar {
    position: absolute;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 20px;
    background: rgba(0,0,0,0.7);
    border: 2px solid #fff;
    border-radius: 10px;
    overflow: hidden;
    display: none;
    z-index: 10;
}
.power-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff3366, #ffd700);
    width: 0%;
    transition: width 0.1s;
}
.controls {
    position: absolute;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
    z-index: 10;
}
.dpad {
    display: flex;
    gap: 10px;
}
.btn {
    background: rgba(255, 255, 255, 0.15);
    border: 3px solid rgba(255, 255, 255, 0.4);
    border-radius: 50%;
    width: 65px;
    height: 65px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    color: white;
    user-select: none;
    cursor: pointer;
    backdrop-filter: blur(10px);
}
.btn:active {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(0.95);
}
.btn-jump {
    background: rgba(255, 51, 102, 0.2);
    border-color: #ff3366;
}
.btn-jump:active {
    background: rgba(255, 51, 102, 0.4);
}
.btn-attack {
    background: rgba(255, 215, 0, 0.2);
    border-color: #ffd700;
    margin-left: 10px;
}
.btn-attack:active {
    background: rgba(255, 215, 0, 0.4);
}
.message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    padding: 40px;
    border-radius: 15px;
    border: 3px solid #ff3366;
    text-align: center;
    display: none;
    z-index: 100;
    max-width: 90%;
}
.message h2 {
    font-size: 36px;
    margin-bottom: 15px;
    color: #ff3366;
}
.message button {
    margin: 10px;
    padding: 12px 30px;
    font-size: 18px;
    background: #ff3366;
    border: none;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    font-weight: bold;
}
.message button:hover {
    background: #ff5588;
}
@media (max-width: 600px) {
    .btn { width: 55px; height: 55px; font-size: 24px; }
    .hud { font-size: 14px; }
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div class="hud">
    <div class="lives">‚ù§Ô∏è <span id="lives">3</span></div>
    <div class="coins">ü™ô <span id="coins">0</span></div>
    <div>‚≠ê <span id="score">0</span></div>
    <div style="color: #ffd700;">üî• <span id="combo">0</span>x</div>
</div>

<div class="level-display">
    Level <span id="levelNum">1</span>
</div>

<div class="combo" id="comboDisplay">COMBO x<span id="comboNum">0</span>!</div>

<div class="power-bar" id="powerBar">
    <div class="power-fill" id="powerFill"></div>
</div>

<div class="controls">
    <div class="dpad">
        <div class="btn" id="leftBtn">‚óÄ</div>
        <div class="btn" id="rightBtn">‚ñ∂</div>
    </div>
    <div style="display: flex;">
        <div class="btn btn-jump" id="jumpBtn">‚Üë</div>
        <div class="btn btn-attack" id="attackBtn">üëä</div>
    </div>
</div>

<div class="message" id="gameOver">
    <h2>Game Over!</h2>
    <div style="font-size: 24px; margin: 10px 0;">Final Score: <span id="finalScore">0</span></div>
    <div style="font-size: 18px; margin: 10px 0;">Continue from Level <span id="continueLevel">1</span></div>
    <button onclick="restart()">Continue</button>
    <button onclick="resetGame()">Start Over</button>
</div>

<div class="message" id="levelComplete">
    <h2>Level Complete! üéâ</h2>
    <div style="font-size: 24px; margin: 10px 0;">Score: <span id="levelScore">0</span></div>
    <div style="font-size: 18px; margin: 10px 0; color: #ffd700;">Max Combo: x<span id="maxCombo">0</span></div>
    <button onclick="nextLevel()">Next Level</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
}
resize();
window.addEventListener('resize', resize);

const game = {
    keys: {},
    player: null,
    camera: { x: 0, y: 0 },
    level: 1,
    maxLevelReached: 1,
    lives: 3,
    coins: 0,
    score: 0,
    combo: 0,
    maxCombo: 0,
    comboTimer: 0,
    entities: [],
    particles: [],
    floatingTexts: [],
    levelWidth: 0,
    gameOver: false,
    levelComplete: false,
    powerMeter: 0
};

// Controls
['leftBtn', 'rightBtn', 'jumpBtn', 'attackBtn'].forEach(id => {
    const btn = document.getElementById(id);
    const key = id.replace('Btn', '');
    
    btn.addEventListener('mousedown', e => { 
        game.keys[key] = true;
        if (key === 'jump') game.keys.jumpPressed = true;
        if (key === 'attack') game.keys.attackPressed = true;
        e.preventDefault();
    });
    btn.addEventListener('mouseup', e => { 
        game.keys[key] = false;
        if (key === 'jump') game.keys.jumpPressed = false;
        if (key === 'attack') game.keys.attackPressed = false;
        e.preventDefault();
    });
    btn.addEventListener('touchstart', e => { 
        game.keys[key] = true;
        if (key === 'jump') game.keys.jumpPressed = true;
        if (key === 'attack') game.keys.attackPressed = true;
        e.preventDefault();
    });
    btn.addEventListener('touchend', e => { 
        game.keys[key] = false;
        if (key === 'jump') game.keys.jumpPressed = false;
        if (key === 'attack') game.keys.attackPressed = false;
        e.preventDefault();
    });
});

window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        if (!game.keys.jump) {
            game.keys.jump = true;
            game.keys.jumpPressed = true;
        }
    }
    if (e.key === 'x' || e.key === 'k') {
        if (!game.keys.attack) {
            game.keys.attack = true;
            game.keys.attackPressed = true;
        }
    }
});
window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') {
        game.keys.jump = false;
        game.keys.jumpPressed = false;
    }
    if (e.key === 'x' || e.key === 'k') {
        game.keys.attack = false;
        game.keys.attackPressed = false;
    }
});

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60;
        this.vy = -2;
    }
    update() {
        this.y += this.vy;
        this.life--;
    }
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        ctx.globalAlpha = this.life / 60;
        ctx.fillStyle = this.color;
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, cx, cy);
        ctx.globalAlpha = 1;
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 32;
        this.h = 48;
        this.vx = 0;
        this.vy = 0;
        this.speed = 6;
        this.jumpPower = -13;
        this.grounded = false;
        this.canJump = true;
        this.facingRight = true;
        this.jumpBufferTime = 0;
        this.coyoteTime = 0;
        this.doubleJumpAvailable = true;
        this.attacking = false;
        this.attackCooldown = 0;
        this.invincible = 0;
        this.dashCooldown = 0;
    }
    
    update() {
        const wasGrounded = this.grounded;
        
        // Dash move
        if ((game.keys.left && game.keys.attack || game.keys.right && game.keys.attack) && this.dashCooldown <= 0) {
            this.vx = (game.keys.right ? 1 : -1) * 12;
            this.dashCooldown = 30;
            for (let i = 0; i < 10; i++) {
                game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, '#00ccff'));
            }
        } else if (game.keys.right) {
            this.vx = this.speed;
            this.facingRight = true;
        } else if (game.keys.left) {
            this.vx = -this.speed;
            this.facingRight = false;
        } else {
            this.vx *= 0.8;
        }
        
        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.invincible > 0) this.invincible--;
        
        this.vy += 0.5;
        if (this.vy > 15) this.vy = 15;
        
        if (!game.keys.jump && this.vy < 0) {
            this.vy *= 0.85;
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        this.grounded = false;
        
        game.entities.forEach(ent => {
            if (ent.type === 'platform') {
                if (this.x < ent.x + ent.w && this.x + this.w > ent.x &&
                    this.y < ent.y + ent.h && this.y + this.h > ent.y) {
                    
                    const overlapX = Math.min(this.x + this.w - ent.x, ent.x + ent.w - this.x);
                    const overlapY = Math.min(this.y + this.h - ent.y, ent.y + ent.h - this.y);
                    
                    if (overlapX < overlapY) {
                        this.x += (this.x < ent.x) ? -overlapX : overlapX;
                        this.vx = 0;
                    } else {
                        if (this.vy > 0) {
                            this.y = ent.y - this.h;
                            this.vy = 0;
                            this.grounded = true;
                            this.canJump = true;
                            this.coyoteTime = 8;
                            this.doubleJumpAvailable = true;
                        } else {
                            this.y = ent.y + ent.h;
                            this.vy = 0;
                        }
                    }
                }
            }
        });
        
        if (!this.grounded && wasGrounded) {
            this.coyoteTime = 8;
        }
        if (this.coyoteTime > 0) this.coyoteTime--;
        
        if (game.keys.jumpPressed) {
            this.jumpBufferTime = 8;
            game.keys.jumpPressed = false;
        }
        if (this.jumpBufferTime > 0) this.jumpBufferTime--;
        
        if (this.jumpBufferTime > 0 && (this.grounded || this.coyoteTime > 0) && this.canJump) {
            this.vy = this.jumpPower;
            this.grounded = false;
            this.canJump = false;
            this.coyoteTime = 0;
            this.jumpBufferTime = 0;
            this.doubleJumpAvailable = true;
        }
        else if (this.jumpBufferTime > 0 && !this.grounded && this.coyoteTime <= 0 && this.doubleJumpAvailable) {
            this.vy = this.jumpPower;
            this.doubleJumpAvailable = false;
            this.jumpBufferTime = 0;
            for (let i = 0; i < 8; i++) {
                game.particles.push(new Particle(this.x + this.w/2, this.y + this.h, '#00ccff'));
            }
        }
        
        // Attack
        if (game.keys.attackPressed && this.attackCooldown <= 0) {
            this.attacking = true;
            this.attackCooldown = 20;
            game.keys.attackPressed = false;
            
            game.entities.forEach(ent => {
                if (ent.type === 'enemy' && !ent.dead) {
                    const dist = Math.hypot(this.x - ent.x, this.y - ent.y);
                    if (dist < 60) {
                        ent.dead = true;
                        addCombo();
                        game.score += 100 * game.combo;
                        updateHUD();
                        game.floatingTexts.push(new FloatingText(ent.x + ent.w/2, ent.y, '+' + (100 * game.combo), '#ffd700'));
                        for (let j = 0; j < 15; j++) {
                            game.particles.push(new Particle(ent.x + ent.w/2, ent.y + ent.h/2, '#ff3366'));
                        }
                    }
                }
            });
        }
        
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.attackCooldown === 0) this.attacking = false;
        
        // Coin collection
        game.entities.forEach((ent, i) => {
            if (ent.type === 'coin' && !ent.collected) {
                const dist = Math.hypot(this.x + this.w/2 - (ent.x + ent.w/2), 
                                       this.y + this.h/2 - (ent.y + ent.h/2));
                if (dist < 30) {
                    ent.collected = true;
                    game.coins++;
                    addCombo();
                    const coinScore = 50 * game.combo;
                    game.score += coinScore;
                    game.powerMeter = Math.min(100, game.powerMeter + 10);
                    updateHUD();
                    game.floatingTexts.push(new FloatingText(ent.x + ent.w/2, ent.y, '+' + coinScore, '#ffd700'));
                    for (let j = 0; j < 10; j++) {
                        game.particles.push(new Particle(ent.x + ent.w/2, ent.y + ent.h/2, '#ffd700'));
                    }
                }
            }
            if (ent.type === 'powerup' && !ent.collected) {
                const dist = Math.hypot(this.x + this.w/2 - (ent.x + ent.w/2), 
                                       this.y + this.h/2 - (ent.y + ent.h/2));
                if (dist < 30) {
                    ent.collected = true;
                    game.lives = Math.min(5, game.lives + 1);
                    game.score += 200;
                    updateHUD();
                    game.floatingTexts.push(new FloatingText(ent.x + ent.w/2, ent.y, '+1 LIFE!', '#ff3366'));
                    for (let j = 0; j < 20; j++) {
                        game.particles.push(new Particle(ent.x + ent.w/2, ent.y + ent.h/2, '#ff3366'));
                    }
                }
            }
        });
        
        // Enemy collision
        game.entities.forEach(ent => {
            if (ent.type === 'enemy' && !ent.dead && this.invincible <= 0) {
                if (this.x < ent.x + ent.w && this.x + this.w > ent.x &&
                    this.y < ent.y + ent.h && this.y + this.h > ent.y) {
                    
                    if (this.vy > 0 && this.y + this.h/2 < ent.y + ent.h/2) {
                        ent.dead = true;
                        this.vy = -10;
                        addCombo();
                        game.score += 100 * game.combo;
                        updateHUD();
                        game.floatingTexts.push(new FloatingText(ent.x + ent.w/2, ent.y, 'STOMP! +' + (100 * game.combo), '#ffd700'));
                        for (let j = 0; j < 15; j++) {
                            game.particles.push(new Particle(ent.x + ent.w/2, ent.y + ent.h/2, '#ff3366'));
                        }
                    } else {
                        this.hit();
                    }
                }
            }
        });
        
        // Goal check
        game.entities.forEach(ent => {
            if (ent.type === 'goal') {
                if (this.x < ent.x + ent.w && this.x + this.w > ent.x &&
                    this.y < ent.y + ent.h && this.y + this.h > ent.y) {
                    levelComplete();
                }
            }
        });
        
        if (this.y > H + 100) {
            this.hit();
        }
    }
    
    hit() {
        if (this.invincible <= 0) {
            game.lives--;
            this.invincible = 120;
            resetCombo();
            updateHUD();
            if (game.lives <= 0) {
                endGame();
            } else {
                this.x = 50;
                this.y = 300;
                this.vx = 0;
                this.vy = 0;
            }
        }
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        
        if (this.invincible > 0 && Math.floor(this.invincible / 5) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        // Skin tone
        ctx.fillStyle = '#fdc689';
        
        // Head
        ctx.fillRect(cx + 8, cy + 4, 16, 16);
        
        // Body (red vest)
        ctx.fillStyle = '#dc143c';
        ctx.fillRect(cx + 10, cy + 20, 12, 12);
        
        // Arms
        ctx.fillStyle = '#fdc689';
        if (this.attacking) {
            if (this.facingRight) {
                ctx.fillRect(cx + 22, cy + 22, 8, 4);
            } else {
                ctx.fillRect(cx + 2, cy + 22, 8, 4);
            }
        } else {
            ctx.fillRect(cx + 6, cy + 22, 4, 10);
            ctx.fillRect(cx + 22, cy + 22, 4, 10);
        }
        
        // Shorts (blue)
        ctx.fillStyle = '#4169e1';
        ctx.fillRect(cx + 10, cy + 32, 12, 8);
        
        // Legs
        ctx.fillStyle = '#fdc689';
        ctx.fillRect(cx + 10, cy + 40, 4, 8);
        ctx.fillRect(cx + 18, cy + 40, 4, 8);
        
        // Eyes
        ctx.fillStyle = '#000';
        if (this.facingRight) {
            ctx.fillRect(cx + 16, cy + 8, 4, 4);
        } else {
            ctx.fillRect(cx + 12, cy + 8, 4, 4);
        }
        
        // Smile
        ctx.fillStyle = '#000';
        ctx.fillRect(cx + 12, cy + 14, 8, 2);
        
        // Straw hat
        ctx.fillStyle = '#f4c542';
        ctx.fillRect(cx + 6, cy + 2, 20, 4);
        ctx.fillRect(cx + 10, cy, 12, 2);
        
        // Hat ribbon
        ctx.fillStyle = '#dc143c';
        ctx.fillRect(cx + 8, cy + 4, 16, 2);
        
        ctx.globalAlpha = 1;
    }
}

class Platform {
    constructor(x, y, w, h, color = '#444') {
        this.type = 'platform';
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = color;
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        ctx.fillStyle = this.color;
        ctx.fillRect(cx, cy, this.w, this.h);
        
        // Grass texture
        ctx.fillStyle = '#3a5a4a';
        for (let i = 0; i < this.w; i += 16) {
            ctx.fillRect(cx + i, cy, 2, 4);
        }
        
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(cx, cy, this.w, this.h);
    }
}

class Coin {
    constructor(x, y) {
        this.type = 'coin';
        this.x = x;
        this.y = y;
        this.w = 24;
        this.h = 24;
        this.collected = false;
        this.angle = 0;
        this.bob = 0;
    }
    
    update() {
        this.angle += 0.1;
        this.bob += 0.1;
    }
    
    draw() {
        if (!this.collected) {
            const cx = this.x - game.camera.x;
            const cy = this.y - game.camera.y + Math.sin(this.bob) * 5;
            ctx.save();
            ctx.translate(cx + this.w/2, cy + this.h/2);
            ctx.rotate(this.angle);
            ctx.fillStyle = '#ffd700';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffed4e';
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    }
}

class PowerUp {
    constructor(x, y) {
        this.type = 'powerup';
        this.x = x;
        this.y = y;
        this.w = 28;
        this.h = 28;
        this.collected = false;
        this.pulse = 0;
    }
    
    update() {
        this.pulse += 0.1;
    }
    
    draw() {
        if (!this.collected) {
            const cx = this.x - game.camera.x;
            const cy = this.y - game.camera.y;
            const scale = 1 + Math.sin(this.pulse) * 0.2;
            ctx.save();
            ctx.translate(cx + this.w/2, cy + this.h/2);
            ctx.scale(scale, scale);
            ctx.fillStyle = '#ff3366';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff3366';
            ctx.beginPath();
            ctx.arc(0, 0, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillRect(-6, -2, 12, 4);
            ctx.fillRect(-2, -6, 4, 12);
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    }
}

class Enemy {
    constructor(x, y, range) {
        this.type = 'enemy';
        this.x = x;
        this.y = y;
        this.w = 36;
        this.h = 36;
        this.startX = x;
        this.range = range;
        this.speed = 2;
        this.dir = 1;
        this.dead = false;
    }
    
    update() {
        if (!this.dead) {
            this.x += this.speed * this.dir;
            if (this.x > this.startX + this.range || this.x < this.startX) {
                this.dir *= -1;
            }
        }
    }
    
    draw() {
        if (!this.dead) {
            const cx = this.x - game.camera.x;
            const cy = this.y - game.camera.y;
            
            ctx.fillStyle = '#0047ab';
            ctx.fillRect(cx + 6, cy + 2, 24, 8);
            
            ctx.fillStyle = '#fdc689';
            ctx.fillRect(cx + 8, cy + 8, 20, 12);
            
            ctx.fillStyle = '#000';
            ctx.fillRect(cx + 12, cy + 12, 3, 3);
            ctx.fillRect(cx + 21, cy + 12, 3, 3);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(cx + 10, cy + 20, 16, 10);
            
            ctx.fillStyle = '#0047ab';
            ctx.fillRect(cx + 10, cy + 20, 16, 2);
            
            ctx.fillStyle = '#000080';
            ctx.fillRect(cx + 12, cy + 30, 12, 6);
            
            ctx.fillStyle = '#0047ab';
            ctx.fillRect(cx + 16, cy + 22, 4, 6);
        }
    }
}

class Goal {
    constructor(x, y) {
        this.type = 'goal';
        this.x = x;
        this.y = y;
        this.w = 48;
        this.h = 64;
        this.pulse = 0;
    }
    
    update() {
        this.pulse += 0.1;
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        const glow = Math.sin(this.pulse) * 10 + 20;
        
        ctx.fillStyle = '#00ff88';
        ctx.shadowBlur = glow;
        ctx.shadowColor = '#00ff88';
        ctx.fillRect(cx, cy, this.w, this.h);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#fff';
        ctx.font = '30px Arial';
        ctx.fillText('üèÅ', cx + 8, cy + 40);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10 - 3;
        this.life = 1;
        this.color = color;
        this.size = Math.random() * 4 + 2;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.3;
        this.life -= 0.02;
    }
    
    draw() {
        const cx = this.x - game.camera.x;
        const cy = this.y - game.camera.y;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(cx, cy, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

function addCombo() {
    game.combo++;
    game.comboTimer = 180;
    if (game.combo > game.maxCombo) {
        game.maxCombo = game.combo;
    }
    if (game.combo > 1) {
        const comboEl = document.getElementById('comboDisplay');
        document.getElementById('comboNum').textContent = game.combo;
        comboEl.style.display = 'block';
        setTimeout(() => { comboEl.style.display = 'none'; }, 1000);
    }
}

function resetCombo() {
    game.combo = 0;
    game.comboTimer = 0;
}

function createLevel(level) {
    game.entities = [];
    
    if (level === 1) {
        game.levelWidth = 3000;
        for (let i = 0; i < 3000; i += 200) {
            game.entities.push(new Platform(i, H - 60, 200, 60, '#2d4a3e'));
        }
        
        game.entities.push(new Platform(300, H - 200, 200, 30));
        game.entities.push(new Platform(600, H - 300, 150, 30));
        game.entities.push(new Platform(900, H - 400, 200, 30));
        game.entities.push(new Platform(1200, H - 250, 180, 30));
        game.entities.push(new Platform(1500, H - 350, 150, 30));
        game.entities.push(new Platform(1800, H - 450, 200, 30));
        game.entities.push(new Platform(2100, H - 300, 180, 30));
        game.entities.push(new Platform(2400, H - 400, 150, 30));
        
        for (let i = 350; i < 3000; i += 200) {
            game.entities.push(new Coin(i, H - 350));
        }
        
        game.entities.push(new PowerUp(1000, H - 450));
        game.entities.push(new PowerUp(2000, H - 350));
        
        game.entities.push(new Enemy(700, H - 340, 100));
        game.entities.push(new Enemy(1300, H - 290, 120));
        game.entities.push(new Enemy(1900, H - 490, 150));
        game.entities.push(new Enemy(2200, H - 340, 100));
        
        game.entities.push(new Goal(2700, H - 460));
    } else if (level === 2) {
        game.levelWidth = 4000;
        game.entities.push(new Platform(0, H - 60, 500, 60, '#2d4a3e'));
        game.entities.push(new Platform(700, H - 60, 600, 60, '#2d4a3e'));
        game.entities.push(new Platform(1500, H - 60, 500, 60, '#2d4a3e'));
        game.entities.push(new Platform(2200, H - 60, 800, 60, '#2d4a3e'));
        game.entities.push(new Platform(3200, H - 60, 800, 60, '#2d4a3e'));
        
        for (let i = 0; i < 8; i++) {
            game.entities.push(new Platform(400 + i * 400, H - 200 - i * 50, 150, 30));
        }
        
        for (let i = 300; i < 4000; i += 180) {
            game.entities.push(new Coin(i, H - 300 - Math.random() * 200));
        }
        
        game.entities.push(new PowerUp(1200, H - 400));
        game.entities.push(new PowerUp(2600, H - 350));
        
        for (let i = 0; i < 10; i++) {
            game.entities.push(new Enemy(600 + i * 400, H - 250 - i * 50, 150));
        }
        
        game.entities.push(new Goal(3700, H - 460));
    } else if (level === 3) {
        game.levelWidth = 5000;
        for (let i = 0; i < 5000; i += 300) {
            game.entities.push(new Platform(i, H - 60, 200, 60, '#2d4a3e'));
        }
        
        for (let i = 0; i < 12; i++) {
            game.entities.push(new Platform(300 + i * 380, H - 250 - Math.random() * 200, 120, 30));
        }
        
        for (let i = 400; i < 5000; i += 150) {
            game.entities.push(new Coin(i, H - 400 - Math.random() * 150));
        }
        
        game.entities.push(new PowerUp(1500, H - 450));
        game.entities.push(new PowerUp(3000, H - 400));
        game.entities.push(new PowerUp(4200, H - 350));
        
        for (let i = 0; i < 15; i++) {
            game.entities.push(new Enemy(500 + i * 320, H - 300, 180));
        }
        
        game.entities.push(new Goal(4700, H - 460));
    }
}

function updateCamera() {
    const targetX = game.player.x - W / 3;
    game.camera.x += (targetX - game.camera.x) * 0.1;
    
    if (game.camera.x < 0) game.camera.x = 0;
    if (game.camera.x > game.levelWidth - W) game.camera.x = game.levelWidth - W;
    
    game.camera.y = 0;
}

function updateHUD() {
    document.getElementById('lives').textContent = game.lives;
    document.getElementById('coins').textContent = game.coins;
    document.getElementById('score').textContent = game.score;
    document.getElementById('combo').textContent = game.combo;
    document.getElementById('levelNum').textContent = game.level;
    
    if (game.combo > 0) {
        document.getElementById('powerBar').style.display = 'block';
        document.getElementById('powerFill').style.width = Math.min(100, game.comboTimer / 180 * 100) + '%';
    } else {
        document.getElementById('powerBar').style.display = 'none';
    }
}

function levelComplete() {
    if (!game.levelComplete) {
        game.levelComplete = true;
        game.score += game.coins * 10 + game.lives * 200 + game.maxCombo * 50;
        
        if (game.level > game.maxLevelReached) {
            game.maxLevelReached = game.level;
        }
        
        document.getElementById('levelScore').textContent = game.score;
        document.getElementById('maxCombo').textContent = game.maxCombo;
        document.getElementById('levelComplete').style.display = 'block';
    }
}

function nextLevel() {
    document.getElementById('levelComplete').style.display = 'none';
    game.level++;
    game.levelComplete = false;
    game.maxCombo = 0;
    resetCombo();
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function endGame() {
    if (!game.gameOver) {
        game.gameOver = true;
        document.getElementById('finalScore').textContent = game.score;
        document.getElementById('continueLevel').textContent = game.maxLevelReached;
        document.getElementById('gameOver').style.display = 'block';
    }
}

function restart() {
    document.getElementById('gameOver').style.display = 'none';
    game.gameOver = false;
    game.levelComplete = false;
    game.level = game.maxLevelReached;
    game.lives = 3;
    game.coins = 0;
    game.maxCombo = 0;
    resetCombo();
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function resetGame() {
    document.getElementById('gameOver').style.display = 'none';
    game.gameOver = false;
    game.levelComplete = false;
    game.level = 1;
    game.maxLevelReached = 1;
    game.lives = 3;
    game.coins = 0;
    game.score = 0;
    game.maxCombo = 0;
    resetCombo();
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function init() {
    game.player = new Player(50, 300);
    createLevel(game.level);
    updateHUD();
}

function draw() {
    const gradient = ctx.createLinearGradient(0, 0, 0, H);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(1, '#16213e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, W, H);
    
    ctx.fillStyle = '#fff';
    for (let i = 0; i < 50; i++) {
        const x = (i * 137.5) % W;
        const y = (i * 73.2) % H;
        ctx.fillRect(x, y, 2, 2);
    }
    
    game.entities.forEach(ent => {
        if (ent.update) ent.update();
        ent.draw();
    });
    
    game.player.draw();
    
    game.particles = game.particles.filter(p => p.life > 0);
    game.particles.forEach(p => {
        p.update();
        p.draw();
    });
    
    game.floatingTexts = game.floatingTexts.filter(t => t.life > 0);
    game.floatingTexts.forEach(t => {
        t.update();
        t.draw();
    });
    
    if (game.comboTimer > 0) {
        game.comboTimer--;
        if (game.comboTimer === 0) {
            resetCombo();
            updateHUD();
        }
    }
}

function loop() {
    if (!game.gameOver && !game.levelComplete) {
        game.player.update();
        updateCamera();
        updateHUD();
    }
    draw();
    requestAnimationFrame(loop);
}

init();
loop();
</script>
</body>
</html>